{% import "macros.jinja" as macros %}
{% import "sql/macros.jinja" as sql_macros %}

{# Use the user-provided db_schema (default public) #}
{% set schema_name = db_schema | default('public') | trim -%}

CREATE EXTENSION IF NOT EXISTS pgcrypto;
{# Only create schema explicitly if it's not the default 'public' #}
{% if schema_name != 'public' %}
CREATE SCHEMA IF NOT EXISTS {{ schema_name }};
{% endif %}

CREATE OR REPLACE FUNCTION update_last_updated_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.last_updated = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

{% for entity_name, entity in entities | items | sort(attribute="1.priority") -%}

{% if entity.enum -%}
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = '{{ entity_name | lower }}_enum') THEN
        CREATE TYPE _color_enum AS ENUM ({{ "'" ~ ( entity.enum | map('string') | join("', '") ) ~ "'" }});
    END IF;
END $$;
{% endif -%}

{% if entity.attributes -%}
{% for prop_name, prop in entity.attributes | items -%}
{% if prop.enum -%}
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = '{{ prop_name | lower }}') THEN
        CREATE TYPE {{ prop_name | lower }} AS ENUM ({{ "'" ~ ( prop.enum | map('string') | join("', '") ) ~ "'" }});
    END IF;
END $$;
{% endif -%}
{% endfor -%}

{% set table_name = entity_name | table_case -%}
CREATE TABLE IF NOT EXISTS {{ schema_name }}.{{ table_name }} (
    {{ sql_macros.pk_column_definition(id_type) }},
    {% set attributes = entity.attributes | items | rejectattr('1.relation','equalto','manyToMany') | rejectattr('1.relation','equalto','oneToMany') -%}
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP{{',' if attributes | length > 0}}
    {% for name, property in attributes -%}
    {% set type = sql_macros.get_sql_type(name, property, name in entity.required) -%}
    {%- if macros.is_relation(property)=='true' and (macros.relation_is_many_to_one(property)=='true' or macros.relation_is_one_to_one(property)=='true') -%}
    {{ sql_macros.add_foreign_key(name, property, schema_name, id_type) }}{{',' if loop.nextitem }}
    {% else -%}
    {{ name | snake_case }} {{ type }}{{',' if loop.nextitem }}
    {% endif -%}
    {% endfor -%}
);

DROP TRIGGER IF EXISTS set_last_updated ON {{ schema_name }}.{{ table_name }};
CREATE TRIGGER set_last_updated
    BEFORE UPDATE ON {{ schema_name }}.{{ table_name }}
    FOR EACH ROW EXECUTE FUNCTION update_last_updated_column();

{% endif -%}
{% endfor -%}

-- m2m junction tables (composite primary keys of the two foreign keys)
{% for relation in macros.get_m2m_relations(entities) | split(',') -%}
{% if relation | trim == '' -%}{% continue -%}{% endif -%}
{% set left = relation | split('_') | first -%}
{% set right = relation | split('_') | last -%}
{% set left_fk = left | foreign_key | trim -%}
{% set right_fk = right | foreign_key | trim -%}
{% set rel_name = relation | trim -%}
CREATE TABLE IF NOT EXISTS {{ rel_name }} (
    {{ left_fk }} {{ sql_macros.foreign_key_column_type(id_type) }} NOT NULL REFERENCES {{ schema_name }}.{{ left | table_case }}(id) ON DELETE CASCADE,
    {{ right_fk }} {{ sql_macros.foreign_key_column_type(id_type) }} NOT NULL REFERENCES {{ schema_name }}.{{ right | table_case }}(id) ON DELETE CASCADE,
    PRIMARY KEY ({{ left_fk }}, {{ right_fk }})
);
CREATE INDEX IF NOT EXISTS idx_{{- rel_name -}}_{{- right_fk -}}_{{- left_fk }} ON {{ rel_name -}} ({{- right_fk -}}, {{- left_fk -}});
{% endfor -%}
