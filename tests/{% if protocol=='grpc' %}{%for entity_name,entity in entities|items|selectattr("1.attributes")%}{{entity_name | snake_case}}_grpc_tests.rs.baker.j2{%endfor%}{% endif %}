{% import "macros.jinja" as macros -%}
{% import "rust/types.jinja" as rust_types -%}
mod common;

use common::TestContext;
use serial_test::serial;
use {{ project_name | snake_case }}::services::{{ project_name | snake_case }}_service::{{ project_name | snake_case }}_proto::{
    {{ entity_name | snake_case }}_service_client::{{ entity_name | pascal_case }}ServiceClient,
    Create{{ entity_name | pascal_case }}Request,
    Update{{ entity_name | pascal_case }}Request,
    Get{{ entity_name | pascal_case }}Request,
    Delete{{ entity_name | pascal_case }}Request,
    List{{ entity_name | plural | pascal_case }}Request,
};

{# Check if entity has required manyToOne or oneToOne relations #}
{% set ns = namespace(has_required_relations=false) -%}
{% for name, property in entity.attributes | items -%}
{% if property.type == 'relation' and property.required and (property.relation == 'manyToOne' or property.relation == 'oneToOne') -%}
{% set ns.has_required_relations = true -%}
{% endif -%}
{% endfor -%}

{% if ns.has_required_relations -%}
use {{ project_name | snake_case }}::services::{{ project_name | snake_case }}_service::{{ project_name | snake_case }}_proto::{
{% for name, property in entity.attributes | items -%}
{% if property.type == 'relation' and property.required and (property.relation == 'manyToOne' or property.relation == 'oneToOne') -%}
    {{ property.target | snake_case }}_service_client::{{ property.target | pascal_case }}ServiceClient,
    Create{{ property.target | pascal_case }}Request,
    Delete{{ property.target | pascal_case }}Request,
{# Also import nested relation clients #}
{% set target_entity = entities[property.target] -%}
{% if target_entity and target_entity.attributes -%}
{% for nested_name, nested_prop in target_entity.attributes | items -%}
{% if nested_prop.type == 'relation' and nested_prop.required and (nested_prop.relation == 'manyToOne' or nested_prop.relation == 'oneToOne') -%}
    {{ nested_prop.target | snake_case }}_service_client::{{ nested_prop.target | pascal_case }}ServiceClient,
    Create{{ nested_prop.target | pascal_case }}Request,
    Delete{{ nested_prop.target | pascal_case }}Request,
{% endif -%}
{% endfor -%}
{% endif -%}
{% endif -%}
{% endfor %}
};
{% endif %}

{# Macro to check if a field is in entity.required list #}
{%- macro is_required(entity, field_name) -%}
{%- if entity.required and field_name in entity.required -%}true{%- else -%}false{%- endif -%}
{%- endmacro -%}

/// Helper to create a valid {{ entity_name | pascal_case }} create request
fn create_{{ entity_name | snake_case }}_request(suffix: &str{% if ns.has_required_relations %}, relation_ids: &std::collections::HashMap<String, String>{% endif %}) -> Create{{ entity_name | pascal_case }}Request {
    Create{{ entity_name | pascal_case }}Request {
{% for name, property in entity.attributes | items -%}
{% set field_required = entity.required and name in entity.required -%}
{% if property.type == 'relation' -%}
{% if property.relation == 'manyToOne' or property.relation == 'oneToOne' -%}
{% if ns.has_required_relations -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}relation_ids.get("{{ property.target | snake_case }}_id").expect("Missing {{ property.target | snake_case }}_id").clone(){% if not field_required %}){% endif %},
{% else -%}
        {{ name | snake_case }}: {% if not field_required %}None{% else %}String::new(){% endif %},
{% endif -%}
{% else -%}
        {{ name | snake_case }}: {% if not field_required %}None{% else %}vec![]{% endif %},
{% endif -%}
{% elif property.readOnly -%}
{# Skip read-only fields #}
{% elif property.enum -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}"{{ property.enum[0] | default('') }}".to_string(){% if not field_required %}){% endif %}, // enum default
{% elif property.type == 'string' -%}
{% if property.format == 'email' -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}"{{ entity_name | snake_case }}_{}_test@example.com".replace("{}", suffix){% if not field_required %}){% endif %},
{% else -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}format!("Test {{ name | title }} {}", suffix){% if not field_required %}){% endif %},
{% endif -%}
{% elif property.type == 'integer' -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}{{ property.default | default(0) }}{% if not field_required %}){% endif %},
{% elif property.type == 'boolean' -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}{{ property.default | default('false') | lower }}{% if not field_required %}){% endif %},
{% elif property.type == 'text' -%}
        {{ name | snake_case }}: {% if not field_required %}Some({% endif %}format!("Test {{ name | title }} content {}", suffix){% if not field_required %}){% endif %},
{% else -%}
        {{ name | snake_case }}: {% if not field_required %}None{% else %}Default::default(){% endif %},
{% endif -%}
{% endfor %}
    }
}

{% if ns.has_required_relations -%}
/// Helper to create required related entities before the main entity
async fn setup_required_relations(ctx: &TestContext, suffix: &str) -> std::collections::HashMap<String, String> {
    let mut relation_ids = std::collections::HashMap::new();

{% for name, property in entity.attributes | items -%}
{% if property.type == 'relation' and property.required and (property.relation == 'manyToOne' or property.relation == 'oneToOne') -%}
{% set target_entity = entities[property.target] -%}
{# First, create any nested required relations for the target entity #}
{% if target_entity and target_entity.attributes -%}
{% for nested_name, nested_prop in target_entity.attributes | items -%}
{% if nested_prop.type == 'relation' and nested_prop.required and (nested_prop.relation == 'manyToOne' or nested_prop.relation == 'oneToOne') -%}
{% set nested_target_entity = entities[nested_prop.target] -%}
    // Create {{ nested_prop.target }} (required by {{ property.target }})
    let mut {{ nested_prop.target | snake_case }}_client = {{ nested_prop.target | pascal_case }}ServiceClient::new(ctx.channel());
    let {{ nested_prop.target | snake_case }}_request = Create{{ nested_prop.target | pascal_case }}Request {
{% if nested_target_entity and nested_target_entity.attributes -%}
{% for attr_name, attr_prop in nested_target_entity.attributes | items -%}
{% set attr_required = nested_target_entity.required and attr_name in nested_target_entity.required -%}
{% if attr_prop.readOnly -%}
{# Skip read-only fields #}
{% elif attr_prop.type == 'relation' -%}
        {{ attr_name | snake_case }}: None,
{% elif attr_prop.enum -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"{{ attr_prop.enum[0] | default('') }}".to_string(){% if not attr_required %}){% endif %},
{% elif attr_prop.type == 'string' -%}
{% if attr_prop.format == 'email' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}format!("{{ nested_prop.target | snake_case }}_for_{{ property.target | snake_case }}_{}_test@example.com", suffix){% if not attr_required %}){% endif %},
{% elif attr_prop.unique -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}format!("Test {{ nested_prop.target }} {{ attr_name | title }} {}", suffix){% if not attr_required %}){% endif %},
{% else -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"Test {{ nested_prop.target }} {{ attr_name | title }}".to_string(){% if not attr_required %}){% endif %},
{% endif -%}
{% elif attr_prop.type == 'integer' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}{{ attr_prop.default | default(0) }}{% if not attr_required %}){% endif %},
{% elif attr_prop.type == 'boolean' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}{{ attr_prop.default | default('false') | lower }}{% if not attr_required %}){% endif %},
{% elif attr_prop.type == 'text' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"Test {{ attr_name | title }} content".to_string(){% if not attr_required %}){% endif %},
{% else -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}None{% else %}Default::default(){% endif %},
{% endif -%}
{% endfor -%}
{% endif %}
    };
    
    let response = {{ nested_prop.target | snake_case }}_client
        .create({{ nested_prop.target | snake_case }}_request)
        .await
        .expect("Failed to create {{ nested_prop.target }}");
    let {{ nested_prop.target | snake_case }}_id = response.into_inner().id;
    relation_ids.insert("{{ nested_prop.target | snake_case }}_id".to_string(), {{ nested_prop.target | snake_case }}_id.clone());

{% endif -%}
{% endfor -%}
{% endif -%}
    // Create {{ property.target }}
    let mut {{ property.target | snake_case }}_client = {{ property.target | pascal_case }}ServiceClient::new(ctx.channel());
    let {{ property.target | snake_case }}_request = Create{{ property.target | pascal_case }}Request {
{% if target_entity and target_entity.attributes -%}
{% for attr_name, attr_prop in target_entity.attributes | items -%}
{% set attr_required = target_entity.required and attr_name in target_entity.required -%}
{% if attr_prop.readOnly -%}
{# Skip read-only fields #}
{% elif attr_prop.type == 'relation' -%}
{% if attr_prop.relation == 'oneToMany' or attr_prop.relation == 'manyToMany' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}None{% else %}vec![]{% endif %},
{% elif attr_prop.required and (attr_prop.relation == 'manyToOne' or attr_prop.relation == 'oneToOne') -%}
        {{ attr_name | snake_case }}: Some({{ attr_prop.target | snake_case }}_id.clone()),
{% else -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}None{% else %}String::new(){% endif %},
{% endif -%}
{% elif attr_prop.enum -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"{{ attr_prop.enum[0] | default('') }}".to_string(){% if not attr_required %}){% endif %}, // enum default
{% elif attr_prop.type == 'string' -%}
{% if attr_prop.format == 'email' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}format!("{{ property.target | snake_case }}_for_{{ entity_name | snake_case }}_{}_test@example.com", suffix){% if not attr_required %}){% endif %},
{% elif attr_prop.unique -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}format!("Test {{ property.target }} {{ attr_name | title }} {}", suffix){% if not attr_required %}){% endif %},
{% else -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"Test {{ property.target }} {{ attr_name | title }}".to_string(){% if not attr_required %}){% endif %},
{% endif -%}
{% elif attr_prop.type == 'integer' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}{{ attr_prop.default | default(0) }}{% if not attr_required %}){% endif %},
{% elif attr_prop.type == 'boolean' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}{{ attr_prop.default | default('false') | lower }}{% if not attr_required %}){% endif %},
{% elif attr_prop.type == 'text' -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}Some({% endif %}"Test {{ attr_name | title }} content".to_string(){% if not attr_required %}){% endif %},
{% else -%}
        {{ attr_name | snake_case }}: {% if not attr_required %}None{% else %}Default::default(){% endif %},
{% endif -%}
{% endfor -%}
{% endif %}
    };
    
    let response = {{ property.target | snake_case }}_client
        .create({{ property.target | snake_case }}_request)
        .await
        .expect("Failed to create {{ property.target }}");
    let {{ property.target | snake_case }}_id = response.into_inner().id;
    relation_ids.insert("{{ property.target | snake_case }}_id".to_string(), {{ property.target | snake_case }}_id);

{% endif -%}
{% endfor %}
    relation_ids
}

/// Helper to cleanup created relations
async fn cleanup_relations(ctx: &TestContext, relation_ids: &std::collections::HashMap<String, String>) {
{% for name, property in entity.attributes | items -%}
{% if property.type == 'relation' and property.required and (property.relation == 'manyToOne' or property.relation == 'oneToOne') -%}
    if let Some(id) = relation_ids.get("{{ property.target | snake_case }}_id") {
        let mut client = {{ property.target | pascal_case }}ServiceClient::new(ctx.channel());
        let _ = client.delete(Delete{{ property.target | pascal_case }}Request { id: id.clone() }).await;
    }
{% set target_entity = entities[property.target] -%}
{% if target_entity and target_entity.attributes -%}
{% for nested_name, nested_prop in target_entity.attributes | items -%}
{% if nested_prop.type == 'relation' and nested_prop.required and (nested_prop.relation == 'manyToOne' or nested_prop.relation == 'oneToOne') -%}
    if let Some(id) = relation_ids.get("{{ nested_prop.target | snake_case }}_id") {
        let mut client = {{ nested_prop.target | pascal_case }}ServiceClient::new(ctx.channel());
        let _ = client.delete(Delete{{ nested_prop.target | pascal_case }}Request { id: id.clone() }).await;
    }
{% endif -%}
{% endfor -%}
{% endif -%}
{% endif -%}
{% endfor %}
}
{% endif %}

// ============================================================================
// CRUD OPERATIONS TESTS
// ============================================================================

#[tokio::test]
#[serial]
async fn test_{{ entity_name | snake_case }}_crud_operations() {
    let ctx = TestContext::new().await;
    let mut client = {{ entity_name | pascal_case }}ServiceClient::new(ctx.channel());
{% if ns.has_required_relations %}
    let relation_ids = setup_required_relations(&ctx, "crud").await;
{% endif %}

    // CREATE
    let create_request = create_{{ entity_name | snake_case }}_request("crud"{% if ns.has_required_relations %}, &relation_ids{% endif %});
    let create_response = client
        .create(create_request)
        .await
        .expect("Failed to create {{ entity_name }}");
    
    let created = create_response.into_inner();
    assert!(!created.id.is_empty(), "Created {{ entity_name }} should have an id");
    let created_id = created.id.clone();

    // READ (Get by ID)
    let get_request = Get{{ entity_name | pascal_case }}Request { id: created_id.clone() };
    let get_response = client
        .get(get_request)
        .await
        .expect("Failed to get {{ entity_name }}");
    
    let fetched = get_response.into_inner();
    assert_eq!(fetched.id, created_id);

    // UPDATE
    let update_request = Update{{ entity_name | pascal_case }}Request {
        id: created_id.clone(),
        created_at: None,
        updated_at: None,
{% for name, property in entity.attributes | items -%}
{% set field_required = entity.required and name in entity.required -%}
{% if property.type == 'relation' -%}
{% if ns.has_required_relations and (property.relation == 'manyToOne' or property.relation == 'oneToOne') -%}
        {{ name | snake_case }}: Some(relation_ids.get("{{ property.target | snake_case }}_id").unwrap().clone()),
{% else -%}
        {{ name | snake_case }}: None,
{% endif -%}
{% elif property.readOnly -%}
{# Skip read-only fields #}
{% elif property.enum -%}
        {{ name | snake_case }}: Some("{{ property.enum[0] | default('') }}".to_string()), // enum default
{% elif property.type == 'string' -%}
{% if property.format == 'email' -%}
        {{ name | snake_case }}: Some("updated_{{ entity_name | snake_case }}_test@example.com".to_string()),
{% else -%}
        {{ name | snake_case }}: Some("Updated {{ name | title }}".to_string()),
{% endif -%}
{% elif property.type == 'integer' -%}
        {{ name | snake_case }}: Some({{ (property.default | default(0)) + 100 }}),
{% elif property.type == 'boolean' -%}
        {{ name | snake_case }}: Some({% if property.default | default('false') | lower == 'true' %}false{% else %}true{% endif %}),
{% elif property.type == 'text' -%}
        {{ name | snake_case }}: Some("Updated {{ name | title }} content".to_string()),
{% else -%}
        {{ name | snake_case }}: None,
{% endif -%}
{% endfor %}
    };
    
    let update_response = client
        .update(update_request)
        .await
        .expect("Failed to update {{ entity_name }}");
    
    let updated = update_response.into_inner();
    assert_eq!(updated.id, created_id);

    // DELETE
    let delete_request = Delete{{ entity_name | pascal_case }}Request { id: created_id.clone() };
    client
        .delete(delete_request)
        .await
        .expect("Failed to delete {{ entity_name }}");

    // Verify deletion - should return NOT_FOUND
    let get_deleted_request = Get{{ entity_name | pascal_case }}Request { id: created_id };
    let get_deleted_result = client.get(get_deleted_request).await;
    assert!(get_deleted_result.is_err());
    let status = get_deleted_result.unwrap_err();
    assert_eq!(status.code(), tonic::Code::NotFound);

{% if ns.has_required_relations %}
    cleanup_relations(&ctx, &relation_ids).await;
{% endif %}
}

// ============================================================================
// LIST OPERATIONS TESTS
// ============================================================================
{% set ns2 = namespace(has_unique_fk=false) -%}
{% for name, property in entity.attributes | items -%}
{% if property.type == 'relation' and property.required and (property.relation == 'oneToOne' or (property.relation == 'manyToOne' and property.mappedBy)) -%}
{% set ns2.has_unique_fk = true -%}
{% endif -%}
{% endfor %}

#[tokio::test]
#[serial]
async fn test_{{ entity_name | snake_case }}_list_operations() {
    let ctx = TestContext::new().await;
    let mut client = {{ entity_name | pascal_case }}ServiceClient::new(ctx.channel());

    // Create multiple entities
    let mut created_ids = Vec::new();
{% if ns.has_required_relations and ns2.has_unique_fk %}
    // Entity has unique FK constraint, need separate relations for each
    let mut all_relation_ids = Vec::new();
    for i in 1..=3 {
        let relation_ids = setup_required_relations(&ctx, &format!("list{}", i)).await;
        let create_request = create_{{ entity_name | snake_case }}_request(&format!("list{}", i), &relation_ids);
        let response = client
            .create(create_request)
            .await
            .expect("Failed to create {{ entity_name }}");
        created_ids.push(response.into_inner().id);
        all_relation_ids.push(relation_ids);
    }
{% elif ns.has_required_relations %}
    let relation_ids = setup_required_relations(&ctx, "list").await;
    for i in 1..=3 {
        let create_request = create_{{ entity_name | snake_case }}_request(&format!("list{}", i), &relation_ids);
        let response = client
            .create(create_request)
            .await
            .expect("Failed to create {{ entity_name }}");
        created_ids.push(response.into_inner().id);
    }
{% else %}
    for i in 1..=3 {
        let create_request = create_{{ entity_name | snake_case }}_request(&format!("list{}", i));
        let response = client
            .create(create_request)
            .await
            .expect("Failed to create {{ entity_name }}");
        created_ids.push(response.into_inner().id);
    }
{% endif %}

    // List all
    let list_request = List{{ entity_name | plural | pascal_case }}Request {
        page_size: 10,
        page_token: String::new(),
    };
    let list_response = client
        .list(list_request)
        .await
        .expect("Failed to list {{ entity_name | plural }}");
    
    let items = list_response.into_inner().{{ entity_name | plural | snake_case }};
    assert!(items.len() >= 3, "Should have at least 3 {{ entity_name | plural }}");

    // Cleanup
    for id in created_ids {
        let delete_request = Delete{{ entity_name | pascal_case }}Request { id };
        let _ = client.delete(delete_request).await;
    }

{% if ns.has_required_relations and ns2.has_unique_fk %}
    for relation_ids in &all_relation_ids {
        cleanup_relations(&ctx, relation_ids).await;
    }
{% elif ns.has_required_relations %}
    cleanup_relations(&ctx, &relation_ids).await;
{% endif %}
}

// ============================================================================
// ERROR HANDLING TESTS
// ============================================================================

#[tokio::test]
#[serial]
async fn test_{{ entity_name | snake_case }}_not_found() {
    let ctx = TestContext::new().await;
    let mut client = {{ entity_name | pascal_case }}ServiceClient::new(ctx.channel());

    // Try to get non-existent entity
{% if id_type == 'uuid' -%}
    let get_request = Get{{ entity_name | pascal_case }}Request { id: "00000000-0000-0000-0000-000000000000".to_string() };
{% else -%}
    let get_request = Get{{ entity_name | pascal_case }}Request { id: "999999".to_string() };
{% endif %}
    let result = client.get(get_request).await;
    
    assert!(result.is_err(), "Getting non-existent entity should fail");
}

#[tokio::test]
#[serial]
async fn test_{{ entity_name | snake_case }}_invalid_id() {
    let ctx = TestContext::new().await;
    let mut client = {{ entity_name | pascal_case }}ServiceClient::new(ctx.channel());

    // Try to get with invalid ID format
    let get_request = Get{{ entity_name | pascal_case }}Request { id: "invalid-id-format".to_string() };
    let result = client.get(get_request).await;
    
    assert!(result.is_err(), "Getting entity with invalid ID should fail");
}
