{% import "macros.jinja" as macros -%}
{% import "rust/types.jinja" as rust_types -%}
{% if authentication == 'keycloak' or authentication == 'jwt' -%}
use std::collections::HashMap;
{% endif -%}
use std::sync::Arc;
{% if database == 'postgres' -%}
use testcontainers::ContainerAsync;
{% if authentication == 'keycloak' -%}
use testcontainers::{GenericImage, ImageExt};
{% endif -%}
use testcontainers_modules::{postgres::Postgres, testcontainers::runners::AsyncRunner};
{% endif -%}
use reqwest::{Client, Response};
{% if authentication == 'keycloak' or authentication == 'jwt' -%}
use serde_json::json;
{% endif -%}
use tokio::process::{Child, Command};
use tokio::sync::OnceCell;
use std::sync::atomic::{AtomicUsize, Ordering};

/// Counter to track active test contexts for cleanup
static CONTEXT_REF_COUNT: AtomicUsize = AtomicUsize::new(0);

/// Response details captured for logging on assertion failures
#[derive(Debug, Clone)]
pub struct ResponseDetails {
    pub url: String,
    pub status: u16,
    pub body: String,
    pub request_body: Option<String>,
}

impl ResponseDetails {
    /// Capture response details from a reqwest Response
    pub async fn capture(response: Response, request_body: Option<&serde_json::Value>) -> (Self, serde_json::Value) {
        let url = response.url().to_string();
        let status = response.status().as_u16();
        let body_text = response.text().await.unwrap_or_else(|_| "<failed to read body>".to_string());
        let body_json: serde_json::Value = serde_json::from_str(&body_text)
            .unwrap_or_else(|_| serde_json::Value::String(body_text.clone()));

        let details = Self {
            url,
            status,
            body: body_text,
            request_body: request_body.map(|b| serde_json::to_string_pretty(b).unwrap_or_default()),
        };

        (details, body_json)
    }

    /// Format for logging
    pub fn format_log(&self) -> String {
        let mut log = format!(
            "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\
             â•‘ ğŸ”´ ASSERTION FAILED - Request/Response Details\n\
             â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\
             â•‘ URL: {}\n\
             â•‘ Status: {}\n",
            self.url, self.status
        );

        if let Some(ref req_body) = self.request_body {
            log.push_str(&format!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\
                                   â•‘ REQUEST BODY:\n"));
            for line in req_body.lines() {
                log.push_str(&format!("â•‘   {}\n", line));
            }
        }

        log.push_str("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\
                      â•‘ RESPONSE BODY:\n");
        // Pretty print JSON if possible
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&self.body) {
            if let Ok(pretty) = serde_json::to_string_pretty(&json) {
                for line in pretty.lines() {
                    log.push_str(&format!("â•‘   {}\n", line));
                }
            } else {
                for line in self.body.lines() {
                    log.push_str(&format!("â•‘   {}\n", line));
                }
            }
        } else {
            for line in self.body.lines() {
                log.push_str(&format!("â•‘   {}\n", line));
            }
        }

        log.push_str("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        log
    }
}

/// Assert that the status code matches expected, logging full request/response on failure
#[macro_export]
macro_rules! assert_status {
    ($details:expr, $expected:expr) => {
        if $details.status != $expected {
            eprintln!("{}", $details.format_log());
            panic!(
                "Status code mismatch: expected {}, got {}",
                $expected, $details.status
            );
        }
    };
    ($details:expr, $expected:expr, $msg:expr) => {
        if $details.status != $expected {
            eprintln!("{}", $details.format_log());
            panic!(
                "{}: expected {}, got {}",
                $msg, $expected, $details.status
            );
        }
    };
}

/// Assert that the status code is a client error (4xx), logging full request/response on failure
#[macro_export]
macro_rules! assert_client_error {
    ($details:expr) => {
        if !($details.status >= 400 && $details.status < 500) {
            eprintln!("{}", $details.format_log());
            panic!(
                "Expected client error (4xx), got {}",
                $details.status
            );
        }
    };
    ($details:expr, $msg:expr) => {
        if !($details.status >= 400 && $details.status < 500) {
            eprintln!("{}", $details.format_log());
            panic!("{}: expected client error (4xx), got {}", $msg, $details.status);
        }
    };
}

/// Shared test context that is initialized once and reused across all tests
static SHARED_CONTEXT: OnceCell<Arc<SharedTestContext>> = OnceCell::const_new();

/// Internal context holding the containers and server process
/// This is kept alive for the duration of all tests
struct SharedTestContext {
{% if database == 'postgres' -%}
    #[allow(dead_code)]
    postgres_container: ContainerAsync<Postgres>,
{% endif -%}
{% if authentication == 'keycloak' -%}
    #[allow(dead_code)]
    keycloak_container: ContainerAsync<GenericImage>,
    keycloak_url: String,
    access_token: String,
{% elif authentication == 'jwt' -%}
    access_token: String,
{% endif -%}
    database_url: String,
    app_url: String,
    client: Client,
    #[allow(dead_code)]
    app_process: Child,
}

impl Drop for SharedTestContext {
    fn drop(&mut self) {
        println!("ğŸ§¹ Cleaning up shared test context...");
{% if database == 'postgres' -%}
        println!("ğŸ˜ Stopping Postgres container...");
{% endif -%}
{% if authentication == 'keycloak' -%}
        println!("ğŸ” Stopping Keycloak container...");
{% endif -%}
        println!("ğŸ–¥ï¸  Stopping application server...");
        // Note: Child process has kill_on_drop(true), so it will be killed automatically
        // Containers will be stopped when they go out of scope
        println!("âœ… Cleanup completed!");
    }
}

/// Public test context that provides access to shared resources
pub struct TestContext {
    inner: Arc<SharedTestContext>,
}

impl TestContext {
    /// Get or initialize the shared test context
    /// This ensures containers and server are only started once
    pub async fn new() -> Self {
        let inner = SHARED_CONTEXT
            .get_or_init(|| async {
                Arc::new(SharedTestContext::initialize().await)
            })
            .await
            .clone();

        // Increment reference count
        CONTEXT_REF_COUNT.fetch_add(1, Ordering::SeqCst);

        Self { inner }
    }

    /// Get the HTTP client for making requests
    pub fn client(&self) -> &Client {
        &self.inner.client
    }

    /// Get the database URL
    #[allow(dead_code)]
    pub fn database_url(&self) -> &str {
        &self.inner.database_url
    }

    /// Get the application base URL (e.g., http://localhost:12345)
    pub fn base_url(&self) -> &str {
        &self.inner.app_url
    }

{% if authentication == 'keycloak' -%}
    /// Get the authorization header for authenticated requests
    pub fn get_auth_header(&self) -> String {
        format!("Bearer {}", self.inner.access_token)
    }
{% elif authentication == 'jwt' -%}
    /// Get the authorization header for authenticated requests
    pub fn get_auth_header(&self) -> String {
        format!("Bearer {}", self.inner.access_token)
    }
{% else -%}
    /// Get the authorization header (no-op when authentication is disabled)
    #[allow(dead_code)]
    pub fn get_auth_header(&self) -> String {
        String::new()
    }
{% endif -%}
}

impl Drop for TestContext {
    fn drop(&mut self) {
        // Decrement reference count
        let prev = CONTEXT_REF_COUNT.fetch_sub(1, Ordering::SeqCst);
        if prev == 1 {
            // This was the last reference, the shared context will be cleaned up
            // when the Arc goes out of scope and its Drop impl is called
            println!("ğŸ“Š All tests completed, shared context will be cleaned up");
        }
    }
}

impl SharedTestContext {
    async fn initialize() -> Self {
        println!("ğŸš€ Initializing shared test context...");

{% if database == 'postgres' -%}
        // Start Postgres container
        println!("ğŸ˜ Starting Postgres container...");
        let postgres_container = Postgres::default()
            .start()
            .await
            .expect("Failed to start Postgres container");

        let postgres_port = postgres_container
            .get_host_port_ipv4(5432)
            .await
            .expect("Failed to get Postgres port");

        let database_url = format!(
            "postgres://postgres:postgres@127.0.0.1:{}/postgres",
            postgres_port
        );
        println!("âœ… Postgres container started on port {}", postgres_port);
{% endif -%}

{% if authentication == 'keycloak' -%}
        // Start Keycloak container
        println!("ğŸ” Starting Keycloak container...");
        let keycloak_container = GenericImage::new("quay.io/keycloak/keycloak", "23.0")
            .with_wait_for(testcontainers::core::WaitFor::message_on_stdout(
                "Running the server in development mode",
            ))
            .with_exposed_port(8080.into())
            .with_env_var("KEYCLOAK_ADMIN", "admin")
            .with_env_var("KEYCLOAK_ADMIN_PASSWORD", "admin")
            .with_env_var("KC_HTTP_ENABLED", "true")
            .with_env_var("KC_HOSTNAME_STRICT", "false")
            .with_cmd(vec!["start-dev"])
            .start()
            .await
            .expect("Failed to start Keycloak container");

        let keycloak_port = keycloak_container
            .get_host_port_ipv4(8080)
            .await
            .expect("Failed to get Keycloak port");

        let keycloak_url = format!("http://127.0.0.1:{}", keycloak_port);
        println!("âœ… Keycloak container started on port {}", keycloak_port);
{% endif -%}

{% if database == 'postgres' and use_sqlx_migrations -%}
        // Note: We don't run migrations here - the server will do it on startup
        // This avoids potential connection pool issues
{% endif -%}

        let client = Client::builder()
            .cookie_store(true)
            .timeout(std::time::Duration::from_secs(5))
            .connect_timeout(std::time::Duration::from_secs(2))
            .build()
            .expect("Failed to create HTTP client");

{% if authentication == 'keycloak' -%}
        // Setup Keycloak realm and client
        println!("ğŸ”§ Setting up Keycloak realm and client...");
        let access_token = Self::setup_keycloak(&client, &keycloak_url).await;
        println!("âœ… Keycloak setup completed");
{% endif -%}

        // Start the application server
        let (app_process, app_url) = Self::start_app_server(
            &client,
            &database_url,
{% if authentication == 'keycloak' -%}
            &keycloak_url,
{% endif -%}
        ).await;

{% if authentication == 'jwt' -%}
        // Setup JWT test user after server is running
        println!("ğŸ”§ Setting up JWT test user...");
        let access_token = Self::setup_jwt_auth(&client, &app_url).await;
        println!("âœ… JWT setup completed");
{% endif -%}

        println!("ğŸ‰ Shared test context initialized successfully!");

        Self {
{% if database == 'postgres' -%}
            postgres_container,
{% endif -%}
{% if authentication == 'keycloak' -%}
            keycloak_container,
            keycloak_url,
            access_token,
{% elif authentication == 'jwt' -%}
            access_token,
{% endif -%}
            database_url,
            app_url,
            client,
            app_process,
        }
    }

    async fn start_app_server(
        client: &Client,
        database_url: &str,
{% if authentication == 'keycloak' -%}
        keycloak_url: &str,
{% endif -%}
    ) -> (Child, String) {
        println!("ğŸ–¥ï¸  Starting application server...");
        println!("ğŸ“ Using DATABASE_URL: {}", database_url);

        // Find an available port by binding to port 0
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("Failed to find available port");
        let port = listener.local_addr().unwrap().port();
        drop(listener); // Release the port so the server can use it
        
        println!("ğŸ“ Using port: {}", port);
        let app_url = format!("http://127.0.0.1:{}", port);

{% if authentication == 'keycloak' -%}
        let issuer = format!("{}/realms/test-realm", keycloak_url);
{% endif -%}

        // Build the binary first to avoid compilation during server start
        let build_status = std::process::Command::new("cargo")
            .args(["build", "--release"])
            .current_dir(env!("CARGO_MANIFEST_DIR"))
            .status()
            .expect("Failed to build application");
        
        if !build_status.success() {
            panic!("Failed to build application");
        }
        println!("âœ… Application built successfully");

        // Now run the built binary directly (not cargo run)
        let binary_path = format!("{}/target/release/{{ project_name | snake_case }}", env!("CARGO_MANIFEST_DIR"));
        let mut cmd = Command::new(&binary_path);
        cmd.env("DATABASE_URL", database_url)
            .env("PORT", port.to_string())
            .env("RUST_LOG", "info")
{% if authentication == 'keycloak' -%}
            .env("ISSUER", &format!("{}/realms/test-realm", keycloak_url))
            .env("CLIENT_ID", "test-client")
            .env("CLIENT_SECRET", "test-secret")
{% endif -%}
            .current_dir(env!("CARGO_MANIFEST_DIR"))
            .stdout(std::process::Stdio::inherit())
            .stderr(std::process::Stdio::inherit())
            .kill_on_drop(true);

        let child = cmd.spawn().expect("Failed to start application");

        // Wait for the app to be ready with retries
        // We check an actual API endpoint to ensure DB is connected
        let mut retries = 60;
        let mut is_ready = false;
        let mut server_responding = false;

        let health_url = format!("{}/api/tags", app_url);
        println!("â³ Waiting for application server to be ready at {}...", app_url);
        while retries > 0 && !is_ready {
            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;

            // Check if server is responding - any HTTP response means it's up
            match client.get(&health_url).send().await {
                Ok(response) => {
                    let status = response.status().as_u16();
                    if !server_responding {
                        println!("   Server responding! First status: {}", status);
                        server_responding = true;
                    }
                    
                    // Any response (even 500 for schema issues) means the app is running
                    // Schema/migration issues are app bugs, not startup issues
                    is_ready = true;
                }
                Err(_) => {
                    // Server not up yet, keep trying
                }
            }

            retries -= 1;
            if retries % 10 == 0 && !is_ready {
                println!("   Still waiting... ({} seconds remaining)", retries);
            }
        }

        if !is_ready {
            panic!("Application server failed to start within 15 seconds");
        }

        println!("âœ… Application server is ready at {}!", app_url);
        (child, app_url)
    }

{% if authentication == 'keycloak' -%}
    async fn setup_keycloak(client: &Client, keycloak_url: &str) -> String {
        // Wait a bit for Keycloak to fully start
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

        // Get admin token
        let admin_token = Self::get_keycloak_admin_token(client, keycloak_url).await;

        // Create realm
        let realm_payload = json!({
            "realm": "test-realm",
            "enabled": true,
            "registrationAllowed": true,
            "resetPasswordAllowed": true
        });

        let _ = client
            .post(format!("{}/admin/realms", keycloak_url))
            .bearer_auth(&admin_token)
            .json(&realm_payload)
            .send()
            .await;

        // Create client
        let client_payload = json!({
            "clientId": "test-client",
            "enabled": true,
            "publicClient": false,
            "secret": "test-secret",
            "redirectUris": ["http://localhost:8080/*"],
            "webOrigins": ["*"],
            "directAccessGrantsEnabled": true,
            "serviceAccountsEnabled": true
        });

        let _ = client
            .post(format!("{}/admin/realms/test-realm/clients", keycloak_url))
            .bearer_auth(&admin_token)
            .json(&client_payload)
            .send()
            .await;

        // Create test user
        let user_payload = json!({
            "username": "testuser",
            "enabled": true,
            "email": "test@example.com",
            "firstName": "Test",
            "lastName": "User",
            "credentials": [{
                "type": "password",
                "value": "testpass",
                "temporary": false
            }]
        });

        let _ = client
            .post(format!("{}/admin/realms/test-realm/users", keycloak_url))
            .bearer_auth(&admin_token)
            .json(&user_payload)
            .send()
            .await;

        // Get and return user access token
        Self::get_user_access_token(client, keycloak_url).await
    }

    async fn get_keycloak_admin_token(client: &Client, keycloak_url: &str) -> String {
        let mut params = HashMap::new();
        params.insert("grant_type", "password");
        params.insert("client_id", "admin-cli");
        params.insert("username", "admin");
        params.insert("password", "admin");

        let response = client
            .post(format!(
                "{}/realms/master/protocol/openid-connect/token",
                keycloak_url
            ))
            .form(&params)
            .send()
            .await
            .expect("Failed to get admin token");

        let json: serde_json::Value = response
            .json()
            .await
            .expect("Failed to parse admin token response");

        json["access_token"]
            .as_str()
            .expect("No access token in response")
            .to_string()
    }

    async fn get_user_access_token(client: &Client, keycloak_url: &str) -> String {
        let mut params = HashMap::new();
        params.insert("grant_type", "password");
        params.insert("client_id", "test-client");
        params.insert("client_secret", "test-secret");
        params.insert("username", "testuser");
        params.insert("password", "testpass");

        let response = client
            .post(format!(
                "{}/realms/test-realm/protocol/openid-connect/token",
                keycloak_url
            ))
            .form(&params)
            .send()
            .await
            .expect("Failed to get user token");

        let json: serde_json::Value = response
            .json()
            .await
            .expect("Failed to parse user token response");

        json["access_token"]
            .as_str()
            .expect("No access token in response")
            .to_string()
    }
{% endif -%}

{% if authentication == 'jwt' -%}
    /// Setup JWT authentication by registering a test user and getting an access token
    async fn setup_jwt_auth(client: &Client, app_url: &str) -> String {
        // Register a test user
        let register_payload = json!({
            "username": "testuser",
            "password": "testpass123",
            "email": "test@example.com"
        });

        let register_response = client
            .post(format!("{}/auth/register", app_url))
            .json(&register_payload)
            .send()
            .await;

        // If registration fails (user might already exist), that's okay
        if let Ok(response) = register_response {
            let status = response.status();
            if !status.is_success() && status.as_u16() != 409 {
                println!("âš ï¸  Registration returned status: {}", status);
            }
        }

        // Login to get access token
        let login_payload = json!({
            "username": "testuser",
            "password": "testpass123"
        });

        let login_response = client
            .post(format!("{}/auth/login", app_url))
            .json(&login_payload)
            .send()
            .await
            .expect("Failed to login test user");

        let status = login_response.status();
        if !status.is_success() {
            panic!("Failed to login test user: status {}", status);
        }

        let json: serde_json::Value = login_response
            .json()
            .await
            .expect("Failed to parse login response");

        json["access_token"]
            .as_str()
            .expect("No access_token in login response")
            .to_string()
    }
{% endif -%}
}
